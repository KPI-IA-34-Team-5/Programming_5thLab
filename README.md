# Лабораторна робота №5
## Тема: Потоки вводу-виводу
## Виконав(-ли): Ковальчук Станіслав, Сухоручкін Гліб, Янович Марія і Ястремський Богдан
---
## Контрольні питання:
### 1. Що таке потоки вводу-виводу?
Потоки вводу-виводу (I/O streams) - це механізм в програмуванні, який дозволяє обмінюватись даними між програмою та зовнішнім середовищем, таким як файли, мережа, клавіатура, екран та інші джерела або призначення даних.

Існують два основних типи потоків вводу-виводу:

1. **Потоки вводу (input streams)**: це потоки, які дозволяють програмі отримувати дані від користувача або з інших джерел, таких як файли, мережа і т.д. Наприклад, коли ви вводите текст з клавіатури у вашу програму, це використовує потік вводу.

2. **Потоки виводу (output streams)**: це потоки, які дозволяють програмі виводити дані на екран, в файл або в інші призначення. Наприклад, коли ваша програма виводить результати обчислення на екран, це використовує потік виводу.

Потоки вводу-виводу важливі для багатьох аспектів програмування, таких як зчитування та запис даних у файли, обробка мережевих з'єднань, робота з клавіатурою та монітором, а також обмін даними між програмами. Вони дозволяють програмі бути більш гнучкою і взаємодіяти з різними джерелами та призначеннями даних.

### 2. Що таке блокуючий і неблокуючий ввід-вивід?
Блокуючий і неблокуючий ввід-вивід (Blocking vs Non-blocking I/O) - це два різних підходи до роботи з потоками вводу-виводу в програмуванні.

1. **Блокуючий ввід-вивід (Blocking I/O)**:
   - У блокуючому ввіді-виводі операції вводу-виводу можуть заблокувати виконання програми до тих пір, поки операція не буде завершена.
   - Наприклад, якщо програма чекає на отримання даних з мережі через блокуючий потік вводу-виводу, вона може призупинити своє виконання, доки дані не будуть доступні або передані.

2. **Неблокуючий ввід-вивід (Non-blocking I/O)**:
   - У неблокуючому ввіді-виводі операції вводу-виводу не блокують виконання програми. Якщо операція не може бути виконана негайно (наприклад, даних немає на вході або вихідний канал не готовий для приймання даних), програма не призупиняє свою роботу, а продовжує виконання інших дій або чекає з іншими ресурсами.

Важливо враховувати, що кожен підхід має свої переваги та недоліки і підходить для різних сценаріїв використання:

- **Блокуючий ввід-вивід** зазвичай просте у використанні, оскільки операції блокуються до завершення, що дозволяє зручно виконувати послідовні дії.
- **Неблокуючий ввід-вивід** дозволяє програмі ефективно використовувати час очікування, не застосовуючи блокування та чекання. Це особливо корисно у високонавантажених системах, де необхідно мінімізувати простій та максимізувати використання ресурсів.

Зазвичай вибір між цими двома підходами залежить від конкретного завдання, вимог продукту та архітектурних рішень.

### 3. Чим InputStream відрізняється від Reader?
`InputStream` і `Reader` є двома абстракціями вводу в Java, і вони використовуються для читання даних з різних джерел. Основна різниця між ними полягає у рівні абстракції та типі даних, які вони обробляють.

1. **InputStream**:
   - `InputStream` є абстракцією для читання байтових даних.
   - Він використовується для читання даних в байтах з різних джерел, таких як файли, мережеві з'єднання, системні вхідні потоки тощо.
   - Наприклад, `FileInputStream` є конкретною реалізацією `InputStream`, яка дозволяє читати дані з файлу байт за байтом.

2. **Reader**:
   - `Reader` є абстракцією для читання символьних даних.
   - Він використовується для читання текстових даних, представлених в символьному форматі, з різних джерел, таких як файли, мережеві з'єднання, системні вхідні потоки тощо.
   - Наприклад, `FileReader` є конкретною реалізацією `Reader`, яка дозволяє читати текст з файлу символ за символом.

Отже, основна відмінність між `InputStream` і `Reader` полягає в тому, що перший працює з байтами, а другий - з символами. Коли ви маєте справу з роботою з текстовими даними, зазвичай краще використовувати `Reader`, оскільки він надає зручний інтерфейс для читання тексту, а також відповідає за правильне кодування символів. Однак, якщо вам потрібно працювати з даними на рівні байтів, вибирайте `InputStream`.

### 4. Якщо потрібно обробити велику кількість байтів а файлі, як це краще всього робити з точки зору швидкодії? Як це краще НЕ робити?
Щоб обробити велику кількість байтів у файлі з точки зору швидкодії:

1. **Краще робити**:
   Використовуйте `InputStream` для роботи з байтами, оскільки це найоптимальніший спосіб читати та обробляти байтові дані у файлі.

2. **Краще не робити**:
   Уникайте використання `Reader`, оскільки він призначений для роботи з символьними даними і може призвести до затримок читання та обробки байтових даних.

### 5. Як працює конструкція try-with-resource? Яким чином слід використовувати цю конструкцію при роботі з файлами?
Конструкція try-with-resources в Java використовується для автоматичного закриття ресурсів після завершення їх використання, навіть якщо виникають винятки під час виконання коду. Це спрощує управління ресурсами та гарантує їх коректне закриття.

Синтаксис конструкції try-with-resources виглядає так:

```java
try (ресурс_1; ресурс_2; ...) {
    // код, що використовує ресурси
} catch (Exception e) {
    // обробка винятків
}
```

У контексті роботи з файлами конструкцію try-with-resources можна використовувати для автоматичного закриття `FileReader`, `BufferedReader`, `FileWriter`, `BufferedWriter` тощо. Наприклад:

```java
try (BufferedReader reader = new BufferedReader(new FileReader("файл.txt"))) {
    String line;
    while ((line = reader.readLine()) != null) {
        // обробка рядка
    }
} catch (IOException e) {
    // обробка винятків
}
```

У цьому прикладі, після завершення блоку try, ресурс `BufferedReader`, який читає дані з файлу, буде автоматично закритий, навіть якщо виникає виняток під час виконання програми.

Такий підхід дозволяє уникнути ручного вибору інструкції `finally`, щоб закрити ресурс, і гарантує коректну обробку ресурсів навіть при виникненні винятків.

### 6. Для чого потрібні методи flush() та close()?
Методи `flush()` і `close()` використовуються для роботи з потоками вводу-виводу в Java, такими як `OutputStream`, `Writer`, `InputStream` і `Reader`. Вони мають різні призначення і використовуються в різних ситуаціях:

1. **Метод `flush()`:**
   - `flush()` вимагає, щоб всі дані, які зберігаються у буфері потоку, були записані у вихідне місце призначення. Це дозволяє вам забезпечити, що всі дані, які ви записали у потік, будуть виведені, навіть якщо буфер ще не заповнений.
   - Наприклад, якщо ви використовуєте `BufferedWriter` для запису тексту у файл, ви можете викликати `flush()`, щоб забезпечити, що усі дані будуть записані у файл без затримки.

2. **Метод `close()`:**
   - `close()` використовується для закриття потоку вводу-виводу після завершення його використання. Це включає в себе закриття зв'язаних ресурсів, таких як файлові дескриптори або мережеві з'єднання.
   - Після виклику `close()` подальші спроби читання або запису у цей потік будуть неможливі, і буде викинуто виключення `IOException`.
   - Важливо завжди закривати потік після його використання, щоб уникнути витоку ресурсів і забезпечити правильну роботу програми.

Отже, користуючись методом `flush()`, ви забезпечуєте виведення всіх даних з буфера потоку, а метод `close()` використовується для закриття потоку та відповідних ресурсів після завершення роботи з ним.

### 7. Чим інтерфейс Set відрізняється від інтерфейсів Collection та List?
Інтерфейси Set, Collection і List є частинами Java Collections Framework і представляють різні типи контейнерів для зберігання даних. Основна відмінність між ними полягає в способах організації та управління елементами:

1. **Collection:**
   - Це базовий інтерфейс, який представляє загальну концепцію групи об'єктів, незалежно від конкретної реалізації.
   - Він включає методи для додавання, видалення, перевірки наявності та інших операцій над елементами колекції.

2. **List:**
   - Інтерфейс List розширює інтерфейс Collection і визначає колекцію, у якій елементи зберігаються у впорядкованій послідовності.
   - Він дозволяє вставляти, додавати, видаляти, знаходити елементи за індексом та інші операції, пов'язані з порядком елементів.

3. **Set:**
   - Інтерфейс Set також розширює інтерфейс Collection, але відрізняється від List тим, що в ньому не може бути дублюючихся елементів.
   - Він представляє собою колекцію, що не дозволяє зберігати однакові елементи більше одного разу, тобто кожен елемент у Set є унікальним.

Отже, основна відмінність між Set і Collection/ List полягає в тому, що Set не допускає наявність дублюючихся елементів, тоді як Collection і List можуть містити дублікати. List, у свою чергу, зберігає елементи у впорядкованій послідовності, що дозволяє доступ до елементів за допомогою індексу, що робить його відмінним від Set.

### 8. HashSet відрізняється від TreeSet?
Інтерфейси HashSet і TreeSet є реалізаціями інтерфейсу Set в Java, але вони мають деякі важливі відмінності:

1. **HashSet:**
   - HashSet базується на хеш-таблиці і використовує хеш-коди елементів для ефективного зберігання та доступу до них.
   - В HashSet порядок елементів не зберігається, тобто елементи можуть виводитися в випадковому порядку при ітерації.
   - Основна перевага HashSet - швидкий доступ до елементів (зазвичай в середньому O(1)).

2. **TreeSet:**
   - TreeSet реалізований як червоно-чорне дерево (Red-Black Tree), що забезпечує впорядковану колекцію елементів за їхнім значенням.
   - Елементи в TreeSet зберігаються відсортовано, що дозволяє використовувати TreeSet для отримання елементів відсортованими за значенням.
   - Основна перевага TreeSet - можливість отримати відсортовану послідовність елементів, а також використовувати методи для пошуку, отримання найменшого/найбільшого елемента тощо.

Отже, основна відмінність між HashSet і TreeSet полягає в тому, що HashSet забезпечує швидкий доступ до елементів, але не зберігає їх у відсортованому порядку, тоді як TreeSet зберігає елементи впорядковано, але може бути трохи менш ефективним у використанні, особливо для додавання/вилучення елементів.

### 9. Що таке хешування, хеш, хеш-код, хеш-функція?
Хешування (англ. hashing) - це процес перетворення даних будь-якого розміру в фіксований рядок фіксованої довжини за допомогою спеціального алгоритму, який називається хеш-функцією. Результат такого перетворення називається хешем (англ. hash).

Основні терміни, пов'язані з хешуванням:

1. **Хеш-код (англ. hash code)**:
   - Хеш-код - це ціле число, отримане з хеш-значення за допомогою хеш-функції.
   - Кожен об'єкт (наприклад, об'єкт класу, рядок, масив тощо) має свій унікальний хеш-код.

2. **Хеш-функція (англ. hash function)**:
   - Хеш-функція - це алгоритм, який приймає вхідні дані будь-якого розміру і перетворює їх у фіксований хеш (хеш-значення) фіксованої довжини.
   - Хеш-функція має властивість, що навіть малі зміни у вхідних даних призводять до великих змін у хеш-значенні.

3. **Хеш (англ. hash)**:
   - Хеш (або хеш-сума) - це результат застосування хеш-функції до вхідних даних, отриманий у вигляді фіксованого рядка бітів або числа.

Хешування широко використовується для забезпечення швидкого доступу до даних у різних алгоритмах та структурах даних. Наприклад, хеш-функції використовуються в хеш-таблицях для швидкого пошуку, в криптографії для створення підписів та хеш-сум файлів для перевірки цілісності даних.

### 10. Яким вимогам має відповідати коректна хеш-функція?
  - швидко обчислюватися;
  - мінімізувати кількість колізій.

### 11. Які властивості притаманні хорошій хеш-функції?
Хороша хеш-функція має кілька важливих властивостей, які дозволяють забезпечити надійність, ефективність і безпеку при її використанні. Основні властивості хорошої хеш-функції включають:

1. **Унікальність**: Кожному різному вхідному набору даних має відповідати унікальне хеш-значення. Тобто, два різних набори даних не повинні мати однаковий хеш.

2. **Розподіленість**: Хеш-функція повинна рівномірно розподіляти хеш-значення по всьому діапазону можливих значень. Це допомагає уникнути надмірної кількості колізій (однакових хешів для різних вхідних даних).

3. **Детермінованість**: Для одного й того ж вхідного набору даних хеш-функція завжди повертає однакове хеш-значення. Це важливо для стабільності та передбачуваності результатів.

4. **Відмінність**: Навіть малі зміни в вхідних даних мають призводити до значних змін у хеш-значенні. Це забезпечує надійність хеш-функції для виявлення навіть малих змін в даних.

5. **Швидкодія обчислення**: Хеш-функція має бути ефективною з точки зору швидкодії обчислення хеш-значення, особливо при великих обсягах даних. Це важливо для швидкодії алгоритмів, що використовують хеш-функцію.

6. **Стійкість до колізій**: Хоча колізії (однакові хеші для різних вхідних даних) не можна уникнути повністю, хеш-функція повинна бути стійкою до колізій, тобто має бути важко знайти два різних набори даних, які мають однаковий хеш.

Забезпечення цих властивостей допомагає зробити хеш-функцію ефективним та безпечним засобом для різних завдань, таких як пошук, індексація, контроль цілісності даних, криптографічні операції тощо.

### 12. Якими критеріям мають відповідати об’єкти для того, щоб посилання на них можна було зберігати у HashSet?
Об'єкти, посилання на які можна зберігати у HashSet, повинні відповідати певним критеріям, оскільки HashSet використовує механізм хешування для зберігання елементів унікально і швидко доступу до них. Основні критерії для об'єктів, що зберігаються в HashSet, включають:

1. **Імплементація методів hashCode() та equals()**:
   - Об'єкти, які зберігаються в HashSet, повинні коректно імплементувати методи `hashCode()` та `equals()`. Метод `hashCode()` повинен генерувати унікальний хеш-код для кожного об'єкта, а метод `equals()` повинен порівнювати об'єкти за їхнім вмістом, а не за посиланням.

2. **Іммутабельність (незмінність)**:
   - Об'єкти, які зберігаються в HashSet, повинні бути іммутабельними або мають імплементувати відповідні методи, щоб їх можна було вважати незмінними для періоду зберігання в множині. Це допоможе уникнути проблем зі зміною хеш-кодів або порушенням унікальності елементів в множині.

3. **Правильна реалізація hashCode() та equals()**:
   - Метод `hashCode()` повинен забезпечити рівномірне розподілення хеш-кодів для різних об'єктів, що допоможе уникнути зайвих колізій.
   - Метод `equals()` повинен бути коректно реалізований для порівняння об'єктів за їхнім вмістом.

4. **Стійкість до змін (при реалізації незмінних об'єктів)**:
   - Якщо об'єкти є незмінними (іммутабельними), вони повинні зберігати свій хеш-код та статус унікальності протягом усього періоду зберігання в HashSet.

Загальною вимогою є те, що об'єкти, які зберігаються в HashSet, повинні вірно реалізувати методи hashCode() та equals(), а також бути стійкими до змін (якщо вони іммутабельні), щоб гарантувати коректну роботу множини і унікальність елементів.

### 13. Які є переваги/недоліки використання HashSet у порівнянні з TreeSet?
HashSet і TreeSet є двома реалізаціями інтерфейсу Set в Java з різними особливостями та властивостями, які впливають на їх використання в різних ситуаціях. Ось переваги і недоліки використання HashSet у порівнянні з TreeSet:

**Переваги HashSet:**

1. **Швидкодія доступу до даних:**
   - HashSet забезпечує швидкий доступ до даних, оскільки використовує хеш-таблицю для зберігання елементів. Середній час доступу до елемента в HashSet є O(1), що робить його дуже ефективним для операцій пошуку, вставки та видалення елементів.

2. **Відсутність сортування:**
   - Елементи в HashSet не зберігаються впорядковано, тому немає додаткових витрат на сортування даних. Це особливо корисно, якщо порядок елементів не має значення для застосування.

3. **Відмінна продуктивність при великій кількості даних:**
   - HashSet зазвичай має кращу продуктивність при великій кількості даних порівняно з TreeSet через швидкий доступ до елементів.

**Недоліки HashSet:**

1. **Відсутність сортування:**
   - Однак, відсутність сортування в HashSet може бути недоліком, якщо потрібно виконати операції над елементами впорядковано.

2. **Не використовує порядок елементів:**
   - Якщо потрібно виконати операції над елементами в порядку їхнього додавання або в іншому визначеному порядку, HashSet не підходить для цього, оскільки не зберігає порядок елементів.

**Переваги TreeSet:**

1. **Впорядкованість елементів:**
   - TreeSet зберігає елементи впорядковано за зростанням (за допомогою компаратора або за замовчуванням - за порівнянням compareTo()), що дозволяє виконувати операції над елементами в певному порядку.

2. **Можливості використання Comparable та Comparator:**
   - TreeSet підтримує використання інтерфейсів Comparable або Comparator для визначення порядку елементів, що дає додаткові можливості управління порядком елементів.

**Недоліки TreeSet:**

1. **Погіршена продуктивність при великій кількості даних:**
   - TreeSet може мати погіршену продуктивність при великій кількості даних через операції, пов'язані з підтримкою впорядкованості елементів.

2. **Більше витрат на пам'ять:**
   - TreeSet може вимагати більше пам'яті для зберігання елементів порівняно з HashSet через потребу у впорядкованості даних.

Отже, обираючи між HashSet і TreeSet, важливо враховувати потреби застосування, продуктивність та вимоги до впорядкування даних. HashSet підходить для швидкодійних операцій над невпорядкованими даними, тоді як TreeSet корисний, якщо потрібно впорядковане зберігання елементів.

### 14. Чим поняття size відрізняється від capacity? Чи може size бути більший за capacity? Чи може capacity бути більший за size? Якщо так, то за яких умов?
Поняття `size` та `capacity` використовуються для опису різних аспектів структур даних, таких як масиви чи колекції.

1. **Розмір (size)**:
   - Розмір (size) структури даних вказує на кількість елементів, які вона фактично містить. Це значення змінюється залежно від операцій додавання, видалення та інших змін в структурі.

2. **Ємність (capacity)**:
   - Ємність (capacity) вказує на кількість елементів, які структура даних може максимально зберігати без необхідності зміни розміру внутрішнього буфера або реалокації пам'яті. Це значення зазвичай фіксоване або змінюється тільки після спеціальних операцій, таких як збільшення ємності.

Тепер щодо відмінностей та можливостей щодо `size` і `capacity`:

- **Size може бути більшим за capacity?**
  - Ні, size не може бути більшим за capacity. Size вказує на фактичну кількість елементів у структурі, тоді як capacity вказує на максимальну кількість елементів, які ця структура може зберігати без розширення.

- **Capacity може бути більшим за size?**
  - Так, capacity може бути більшим за size. Це часто відбувається в контексті динамічних структур даних, таких як ArrayList в Java. Наприклад, коли ми додаємо елементи до ArrayList, capacity може збільшуватися, але size зростає тільки тоді, коли фактично додається новий елемент.

Резюмуючи, size вказує на фактичну кількість елементів, а capacity вказує на максимальну кількість елементів, яку структура даних може зберігати. Size не може перевищувати capacity, але capacity може бути більшим за size, особливо в динамічних структурах даних, які можуть змінювати свою ємність відповідно до змін у розмірі.

### 15. Що таке load factor та на що і як він впливає?
Load factor - це співвідношення між кількістю елементів, які зберігаються в хеш-таблиці, та загальною кількістю доступних "слотів" у цій таблиці. Впливає на ефективність роботи хеш-таблиці: низький load factor сприяє меншим колізіям, але займає більше пам'яті, високий load factor економічний з точки зору пам'яті, але може призвести до збільшення кількості колізій та втрати продуктивності.

### 16. Що таке асоціативний масив? Чим ключ відрізняється від значення?
Асоціативний масив - це структура даних, що забезпечує відображення ключів на значення. Ключ визначає унікальність елемента в масиві та використовується для доступу до відповідного значення. Значення ж є інформацією, яка зберігається під певним ключем та доступна за його допомогою.

### 17. Чи може в асоціативному масиві зберігатись кілька однакових ключів або однакових значень?
В асоціативному масиві кожен ключ повинен бути унікальним, тобто не може існувати два однакових ключі, оскільки ключ визначає однозначний зв'язок зі значенням. Однак, щодо значень, вони можуть бути повторюваними. Тобто в асоціативному масиві може бути кілька записів з однаковим значенням, але з різними ключами.

### 18. До яких наслідків може привести зберігання неімутабельних об’єктів у HashSet, у HashMap в якості ключа та у HashMap в якості значення?
Зберігання неімутабельних об'єктів у колекціях, таких як HashSet (для унікальних значень), HashMap (для ключів) та HashMap (для значень), може мати наступні наслідки:

1. **HashSet з неімутабельними об'єктами:**
   - Якщо використовуються неімутабельні об'єкти в HashSet, то зміна цих об'єктів після додавання їх до множини може призвести до непередбачуваного поведінки, оскільки множина буде порівнювати об'єкти за їхнім станом. Це може призвести до того, що один і той же об'єкт може бути доданий до множини з різними значеннями.

2. **HashMap з неімутабельними об'єктами як ключами:**
   - Якщо використовуються неімутабельні об'єкти як ключі в HashMap, і якщо ці об'єкти змінюють свій стан після додавання до колекції, то вони можуть "загубитись" у мапі, оскільки хеш-коди об'єктів змінюються і вони більше не можуть бути знайдені за старим ключем. Це може призвести до втрати даних або непередбачуваного доступу до значень.

3. **HashMap з неімутабельними об'єктами як значеннями:**
   - Якщо використовуються неімутабельні об'єкти як значення в HashMap, то ці об'єкти можуть бути модифіковані із зовнішніх джерел, що призведе до зміни значень в колекції. Це може порушити цілісність даних, оскільки значення, які зберігаються в колекції, можуть бути несправжніми або застарілими.

Щоб уникнути цих проблем, зазвичай рекомендується використовувати імутабельні об'єкти як ключі та значення в колекціях типу HashSet та HashMap. Це дозволить гарантувати стабільність даних та уникнути непередбачуваної поведінки при використанні цих колекцій.

### 19. Чи можуть об’єкти без інтерфейсу Comparable зберігатись у TreeMap? 
Ні, об'єкти без імплементації інтерфейсу Comparable не можуть зберігатись у TreeMap. TreeMap використовує порівняння ключів для впорядкування елементів у внутрішній структурі даних, і для цього ключі повинні бути порівнюваними між собою. Якщо об'єкти ключів не імплементують інтерфейс Comparable або не надають зовнішнього Comparator для порівняння, TreeMap не зможе визначити правильний порядок для цих об'єктів і виникне помилка під час вставки.

### 20. Чи можуть об’єкти без інтерфейсу Comparable зберігатись у HashMap? Чи взагалі впливає на щось наявність у об’єктів інтерфейсу Comparable при зберіганні у HashMap?
Так, об'єкти без інтерфейсу Comparable можуть зберігатись у HashMap. У випадку HashMap порівняння ключів не відбувається за допомогою інтерфейсу Comparable або зовнішнього Comparator, як це відбувається у TreeMap. В HashMap порівняння ключів відбувається за допомогою методу `equals()` та хеш-кодів ключів.

Наявність інтерфейсу Comparable у ключа не впливає на сам процес зберігання у HashMap. Однак, це може вплинути на розуміння та очікувану поведінку програми. Якщо ключі мають можливість порівнюватись за допомогою інтерфейсу Comparable, це може вплинути на деякі операції, наприклад, при використанні методів `Collections.sort()` або при переборі елементів у відсортованому порядку.

Загалом, для HashMap головне, щоб ключі коректно реалізували методи `equals()` та `hashCode()`, оскільки саме за цими методами відбувається пошук та збереження елементів у внутрішній структурі HashMap.



---
## Висновки:
У ході цієї лаборатоної роботи, ми дізналися повторили потоки вводу-виводу, а також повторили деякі дуже потрібні структури даних
